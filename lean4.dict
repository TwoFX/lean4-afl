keyword_theorem="theorem"
keyword_def="def"
keyword_let="let"
keyword_fun="fun"
keyword_eval="#eval"
keyword_check="#check"
keyword_inductive="inductive"
keyword_print="print"
keyword_where="where"
keyword_rfl="rfl"
keyword_reduce="#reduce"
keyword_sorry="sorry"
keyword_notation="notation"
keyword_infixl="infixl"
keyword_infixr="infixr"
keyword_namespace="namespace"
keyword_section="section"
keyword_end="end"
keyword_True="True"
keyword_False="False"
keyword_true="true"
keyword_false="false"
keyword_do="do"
keyword_from="from"
keyword_if="if"
keyword_then="then"
keyword_else="else"
keyword_noncomputable="noncomputable"
keyword_forall="forall"
keyword_Exists="Exists"
keyword_Iff="Iff"
keyword_Prop="Prop"
keyword_trivial="trivial"
keyword_structure="structure"
keyword_match="match"
keyword_extends="extends"
keyword_mutual="mutual"
keyword_abbreviation="abbreviation"

keyword_by="by"
tactic_intro="intro"
tactic_cases="cases"
tactic_apply="apply"
tactic_refl="refl"

operator_vert="|"
operator_funarrow="=>"
operator_hole="_"

type_Nat="Nat"
type_Array="Array"
type_Bool="Bool"
type_List="List"

snippet_coloneqq=" := "
snippet_main="def main : IO Unit :="
snippet_notation1="notation:50 a \"**\" b:50 => b * a * b"
snippet_notation2="notation \"~\" a => a+a"
snippet_lambda1="fun _ => _"
snippet_lambda2="fun a => a + 1"
snippet_lambda3="fun a => a"
snippet_lambda4="fun a => sorry"
snippet_lambda5="fun a b => a"
snippet_lambda6="fun a b c => a"
snippet_if1="if x then a else b"
snippet_if2="if true then 0 else 1"
snippet_if3="if _ then _ else _"
snippet_ProofOfFalse="theorem hello : False :="
snippet_ProofOfTrue="theorem goodbye : True := trivial"
